
import java_cup.runtime.*;

terminal READ;
terminal PRINT;
terminal PRINTLINE;
terminal CLASS;
terminal VOID;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;
terminal TRUE;
terminal FALSE;
terminal TIMES;
terminal PLUS;
terminal MINUS;
terminal PREFIXPLUS;
terminal PREFIXMINUS;
terminal DIVIDE;
terminal SEMI;
terminal EQ;
terminal ASSMNT;
terminal LT;
terminal GT;
terminal LTE;
terminal GTE;
terminal NOT_EQ;
terminal OR;
terminal AND;
terminal L_BRACKET;
terminal R_BRACKET;
terminal L_PARAN;
terminal R_PARAN;
terminal L_BRACE;
terminal R_BRACE;
terminal NEGATION;
terminal TERNARY;
terminal COLON;
terminal FINAL;
terminal INCREMENT;
terminal DECREMENT;
terminal COMMA;

terminal String INT;
terminal String FLOAT;
terminal String BOOL;
terminal String CHAR;

terminal String ID;
terminal int INTLIT;
terminal double FLOATLIT;
terminal String CHARLIT;
terminal String STRLIT;


/*
 * this dummy token is necessary, since at least one non-terminal is
 * required to run cup
 */
non terminal Program program;
non terminal Memberdecls memberdecls;
non terminal Fielddecls fielddecls;
non terminal Fielddecl fielddecl;
non terminal Methoddecls methoddecls;
non terminal Methoddecl methoddecl;
non terminal Boolean optionalfinal;
non terminal Expr optionalexpr;
non terminal Boolean optionalsemi;
// non terminal Returntype returntype;
non terminal String type;
non terminal Argdecls argdecls;
non terminal ArgdeclList argdeclList;
non terminal Argdecl argdecl;
non terminal Stmts stmts;
non terminal Stmt stmt;
non terminal Stmt ifEnd; 
non terminal Name name;
non terminal Args args;
non terminal Readlist readlist;
non terminal Printlist printlist;
non terminal Printlinelist printlinelist;
non terminal Expr expr;
non terminal BinaryOp binaryOp;

precedence left PLUS, MINUS; 
precedence left TIMES, DIVIDE; 

// Productions

program ::= CLASS ID:id L_BRACE memberdecls:mds R_BRACE
            {:  RESULT = new Program(id, mds);  :}
            ;

memberdecls ::= fielddecls:fds methoddecls:mds
            {:  RESULT = new Memberdecls(fds, mds);  :}
            ;

fielddecls ::= fielddecl:fd fielddecls:fds 
            {:  RESULT = new Fielddecls(fd, fds);  :}
            | {:  RESULT = new Fielddecls();  :} /* the empty production */
            ;

methoddecls ::= methoddecl:md methoddecls:mds
            {: RESULT = new Methoddecls(md, mds);  :}
            | {:  RESULT = new Methoddecls();  :} /* the empty production */;


fielddecl ::= FINAL type:t ID:id optionalexpr:oe SEMI
          {: RESULT = new Fielddecl(true, t, id, oe);  :}
          | type:t ID:id optionalexpr:oe SEMI
          {: RESULT = new Fielddecl(false, t, id,oe);  :}
          | type:t ID:id L_BRACKET INTLIT:intliteral R_BRACKET SEMI
          {: RESULT = new Fielddecl(t, id, intliteral);  :}
          ;

optionalfinal ::= FINAL 
                {: RESULT = true;  :}
            | {: RESULT = false;  :}
            ;

optionalexpr ::= ASSMNT expr:ex
             {: RESULT = ex;  :}
            | {: RESULT = null;  :} /* the empty production */
            ;

methoddecl ::= type:t ID:id L_PARAN argdecls:a R_PARAN L_BRACE fielddecls:fds stmts:sts R_BRACE optionalsemi:opt
            {: RESULT = new Methoddecl(t, id, a, fds, sts, opt);  :}
            | VOID ID:id L_PARAN argdecls:a R_PARAN L_BRACE fielddecls:fds stmts:sts R_BRACE optionalsemi:opt
            {: RESULT = new Methoddecl("void", id, a, fds, sts, opt);  :}
            ;

optionalsemi ::= SEMI 
                {: RESULT = true;  :}
             | 
             {: RESULT = false;  :}
             ;


// returntype ::= type:t 
//                {: RESULT = new Returntype(t);  :};
        //     | VOID 
        //         {: RESULT =  new returntype('void');  :}
        //     ;


type ::= INT 
        {: RESULT = "int";  :}
        | CHAR 
        {: RESULT = "char";  :}
        | BOOL 
        {: RESULT = "bool";  :}
        | FLOAT
        {: RESULT = "float";  :}
        ;

argdecls ::= argdeclList:adl 
            {: RESULT =  new Argdecls(adl);  :}
            | {: RESULT =  new Argdecls();  :} /* the empty production */
            ;

argdeclList ::= argdecl:ad COMMA argdeclList:adl 
            {: RESULT = new ArgdeclList(ad, adl);  :}
            |
            argdecl:ad
            {: RESULT = new ArgdeclList(ad);  :}
            ;

argdecl ::= type:t ID:id
            {: RESULT = new Argdecl(t, id, false);  :}
            |
            type:t ID:id L_BRACKET R_BRACKET
            {: RESULT = new Argdecl(t, id, true); :}
            ;


stmts ::= stmt:s stmts:ss 
      {: RESULT = new Stmts(s, ss);  :}
      | {: RESULT = new Stmts();  :} /* the empty production */
      ;


stmt ::= IF L_PARAN expr:ex R_PARAN stmt:st ifEnd:ie  // if else
        {: RESULT = new Stmt(ex, st, ie);  :}
        | WHILE L_PARAN expr:ex R_PARAN stmt:st  // while
        {: RESULT = new Stmt(ex, st);  :}
        | name:n ASSMNT expr:ex SEMI // assignment stmt
        {: RESULT = new Stmt(n, ex);  :}
        | READ L_PARAN readlist:rl R_PARAN SEMI // read stmt
        {: RESULT = new Stmt(rl);  :}
        | PRINT L_PARAN printlist:pl R_PARAN SEMI // print stmt
        {: RESULT = new Stmt(pl);  :}
        | PRINTLINE L_PARAN printlinelist:pll R_PARAN SEMI // print line stmt
        {: RESULT = new Stmt(pll);  :}
        | ID:id L_PARAN R_PARAN SEMI // fn call without args
        {: RESULT = new Stmt(id);  :}
        | ID:id L_PARAN args:a R_PARAN SEMI // fn call with args
        {: RESULT = new Stmt(id, a);  :}
        | RETURN SEMI // return
        {: RESULT = new Stmt();  :}
        | RETURN expr:e SEMI // return with value
        {: RESULT = new Stmt(e);  :}
        | name:n INCREMENT SEMI // inc the value of var
        {: RESULT = new Stmt(n, "inc");  :}
        | name:n DECREMENT SEMI // dec the value of var
        {: RESULT = new Stmt(n, "dec");  :}
        | L_BRACE fielddecls:fd stmts:sts R_BRACE Optionalsemi:opt // blocks
        {: RESULT = new Stmt(fd, sts, opt);  :}
        ;

ifEnd ::= ELSE stmt:s 
        {: RESULT = s;  :}
        | {: RESULT = null;  :} /* the empty production */
        ;

name ::= ID:id 
        {: RESULT = new Name(id);  :}
        | ID:id L_BRACKET expr:ex R_BRACKET
        {: RESULT = new Name(id, ex);  :}
        ;

args ::= expr:ex COMMA args:a
      {: RESULT = new Args(ex, a);  :}
      | expr:ex
      {: RESULT = new Args(ex);  :}
      ;

readlist ::= name:n COMMA readlist:r
      {: RESULT = new Readlist(n, r);  :}
      | name:n
      {: RESULT = new Readlist(n);  :}
      ;


printlist ::= expr:ex COMMA printlist:pl
          {: RESULT = new Printlist(ex, pl);  :}
         | expr: ex
         {: RESULT = new Printlist(ex);  :}
        ;


printlinelist ::= printlist:p
              {: RESULT = new Printlinelist(p);  :}
              | {: RESULT = new Printlinelist();  :} /* the empty production */
              ;



expr ::= name:n 
        {: RESULT = new Expr(n);  :}
        | ID:id L_PARAN R_PARAN 
        {: RESULT = new Expr(id, null);  :}
        | ID:id L_PARAN args:a R_PARAN 
        {: RESULT = new Expr(id, a);  :}
        | INTLIT:il 
        {: RESULT = new Expr(Integer.parseInt(il));  :}
        | CHARLIT:cl 
        {: RESULT = new Expr(cl, "char");  :}
        | STRLIT:sl 
        {: RESULT = new Expr(sl, "str");  :}
        | FLOATLIT:fl 
        {: RESULT = new Expr(Float.parseFloat(fl));  :}
        | TRUE
        {: RESULT = new Expr(true);  :}
        | FALSE
        {: RESULT = new Expr(false);  :}
        | L_PARAN expr:e R_PARAN 
        {: RESULT = new Expr(e, "PARA");  :}
        | NEGATION expr:e 
        {: RESULT = new Expr(e, "~");  :}
        | PREFIXMINUS expr:e 
        {: RESULT = new Expr(e, "-");  :}
        | PREFIXPLUS expr:e
        {: RESULT = new Expr(e, "+");  :}
        | L_PARAN type:t R_PARAN expr:e 
        {: RESULT = new Expr(t, e);  :}
        | binaryOp:bo
        {: RESULT = new Expr(bo);  :}
        | L_PARAN expr:e1 TERNARY expr:e2 COLON expr:e3 R_PARAN 
        {: RESULT = new Expr(e1, e2, e3);  :}
        ;


binaryOp ::= expr:e1 TIMES expr:e2
        {: RESULT = new BinaryOp(e1, e2, "*");  :}
        | expr:e1 DIVIDE expr:e2
        {: RESULT = new BinaryOp(e1, e2"/");  :}
        | expr:e1 PLUS expr:e2
        {: RESULT = new BinaryOp(e1, e2, "+");  :}
        | expr:e1 MINUS expr:e2
        {: RESULT = new BinaryOp(e1, e2, "-");  :}
        | expr:e1 LT expr:e2
        {: RESULT = new BinaryOp(e1, e2, "<");  :}
        | expr:e1 GT expr:e2
        {: RESULT = new BinaryOp(e1, e2, ">");  :}
        | expr:e1 LTE expr:e2
        {: RESULT = new BinaryOp(e1, e2, "<=");  :}
        | expr:e1 GTE expr:e2
        {: RESULT = new BinaryOp(e1, e2, ">=");  :}
        | expr:e1 EQ expr:e2
        {: RESULT = new BinaryOp(e1, e2, "==");  :}
        | expr:e1 NOT_EQ expr:e2
        {: RESULT = new BinaryOp(e1, e2, "<>");  :}
        | expr:e1 OR expr:e2
        {: RESULT = new BinaryOp(e1, e2, "||");  :}
        | expr:e1 AND expr:e2
        {: RESULT = new BinaryOp(e1, e2, "&&");  :}

