
import java_cup.runtime.*;

terminal READ;
terminal PRINT;
terminal PRINTLINE;
terminal CLASS;
terminal VOID;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;
terminal TRUE;
terminal FALSE;
terminal TIMES;
terminal PLUS;
terminal MINUS;
terminal PREFIXPLUS;
terminal PREFIXMINUS;
terminal DIVIDE;
terminal SEMI;
terminal EQ;
terminal ASSMNT;
terminal LT;
terminal GT;
terminal LTE;
terminal GTE;
terminal NOT_EQ;
terminal OR;
terminal AND;
terminal L_BRACKET;
terminal R_BRACKET;
terminal L_PARAN;
terminal R_PARAN;
terminal L_BRACE;
terminal R_BRACE;
terminal NEGATION;
terminal TERNARY;
terminal COLON;
terminal FINAL;
terminal INCREMENT;
terminal DECREMENT;
terminal COMMA;

terminal String INT;
terminal String FLOAT;
terminal String BOOL;
terminal String CHAR;

terminal String ID;
terminal int INTLIT;
terminal double FLOATLIT;
terminal String CHARLIT;
terminal String STRLIT;


/*
 * this dummy token is necessary, since at least one non-terminal is
 * required to run cup
 */
non terminal Program program;
non terminal Memberdecls memberdecls;
non terminal Fielddecls fielddecls;
non terminal Fielddecl fielddecl;
non terminal Methoddecls methoddecls;
non terminal Methoddecl methoddecl;
non terminal Boolean optionalfinal;
non terminal Expr optionalexpr;
non terminal Boolean optionalsemi;
// non terminal Returntype returntype;
non terminal String type;
non terminal Argdecls argdecls;
non terminal ArgdeclList argdeclList;
non terminal Argdecl argdecl;
non terminal Stmts stmts;
non terminal Stmt stmt;
non terminal IfEnd ifEnd; 
non terminal Name name;
non terminal Args args;
non terminal Readlist readlist;
non terminal Printlist printlist;
non terminal Printlinelist printlinelist;
non terminal Expr expr;
non terminal BinaryOp binaryOp;

precedence left PLUS, MINUS; 
precedence left TIMES, DIVIDE; 

// Productions

program ::= CLASS ID:id L_BRACE memberdecls:mds R_BRACE
            {:  RESULT = new Program(id, mds);  :}
            ;

// FOR TESTING
// memberdecls ::= methoddecls:m 
//             {:  RESULT = new Memberdecls(m);  :}
//             ;


memberdecls ::= fielddecls:f methoddecls:m 
            {:  RESULT = new Memberdecls(f, m);  :}
            ;

fielddecls ::= fielddecl:fd fielddecls:fds 
            {:  RESULT = new fielddecls(fd, fds);  :}
            | /* the empty production */
            ;

methoddecls ::= methoddecl:md methoddecls:mds
            {: RESULT = new Methoddecls(md, mds);  :}
            | /* the empty production */;

// FOR TESTING
// methoddecls ::= methoddecl:md 
//             {: RESULT = new Methoddecls(md);  :};
        //     | /* the empty production */;

fielddecl ::= optionalfinal:of type:t ID:id optionalexpr:oe SEMI
          {: RESULT = new fielddecl(of, t, i, oe);  :}
          |
          type:t ID:i L_BRACKET INTLIT:i R_BRACKET SEMI 
          {: RESULT = new fielddecl(t, i);  :}
          ;

optionalfinal ::= FINAL 
                {: RESULT = true;  :}
            | {: RESULT = false;  :}
            ;

optionalexpr ::= ASSMNT expr:ex
             {: RESULT = ex;  :}
            | {: RESULT = null;  :} /* the empty production */
            ;

// FOR TESTING
// methoddecl ::= returntype:rt ID:i L_PARAN argdecls:a R_PARAN L_BRACE fielddecls:fd stmts:s R_BRACE optionalsemi
//             {: RESULT = new methoddecl(rt, i, a, fd, s);  :}
//             ;

// methoddecl ::= type:t ID:id L_PARAN argdecls:a R_PARAN L_BRACE stmts:s R_BRACE optionalsemi
//             {: RESULT = new Methoddecl(t, i, a, s);  :}
//             ;

methoddecl ::= type:t ID:id L_PARAN argdecls:a R_PARAN L_BRACE fielddecls:fds stmts:st R_BRACE optionalsemi:opt
            {: RESULT = new Methoddecl(t, id, a, fds, st, opt);  :}
            | type:t ID:id L_PARAN argdecls:a R_PARAN L_BRACE fielddecls:fds stmts:st R_BRACE optionalsemi:opt
            {: RESULT = new Methoddecl("void", id, a, fds, st, opt);  :}
            ;

optionalsemi ::= SEMI 
                {: RESULT = true;  :}
             | 
             {: RESULT = false;  :}
             ;


// returntype ::= type:t 
//                {: RESULT = new Returntype(t);  :};
        //     | VOID 
        //         {: RESULT =  new returntype('void');  :}
        //     ;


type ::= INT 
        {: RESULT = "int";  :}
        | CHAR 
        {: RESULT = "char";  :}
        | BOOL 
        {: RESULT = "bool";  :}
        | FLOAT
        {: RESULT = "float";  :}
        ;

// argdecls ::= argdeclList:a 
//             {: RESULT =  new Argdecls(a);  :}
//             | /* the empty production */
//             ;

// argdeclList ::= argdecl:ad COMMA argdeclList:adl 
//             {: RESULT = new ArgdeclList(ad, adl, false);  :}
//             |
//             argdecl:ad 
//             {: RESULT = new ArgdeclList(ad, null, true);  :}
//             ;

// argdecl ::= type:t ID:i 
//             {: RESULT = new Argdecl(t, i, false);  :}
//             |
//             type:t ID: i L_BRACKET R_BRACKET
//             {: RESULT = new Argdecl(t, i, true); :}
//             ;


// stmts ::= stmt:s stmts:ss 
//       {: RESULT = new Stmts(s, ss);  :}
//       | /* the empty production */
//       ;

stmt ::= PRINT L_PARAN name:pl R_PARAN SEMI
        {: RESULT = new Stmt(pl);  :}
        ;

// stmt ::= IF L_PARAN expr:e R_PARAN stmt:s ifEnd:ie 
//         {: RESULT = new stmt(1, e, s, ie);  :}
//         | WHILE L_PARAN expr:e R_PARAN stmt:s 
//         {: RESULT = new stmt(2, e, s);  :}
//         | name:n ASSMNT expr:e SEMI
//         {: RESULT = new stmt(3, n, e);  :}
//         | READ L_PARAN readlist:rl R_PARAN SEMI
//         {: RESULT = new stmt(4, rl);  :}
//         | PRINT L_PARAN printlist:pl R_PARAN SEMI
//         {: RESULT = new stmt(5, pl);  :}
//         | PRINTLINE L_PARAN printlinelist:pll R_PARAN SEMI
//         {: RESULT = new stmt(6, pll);  :}
//         | ID:i L_PARAN R_PARAN SEMI
//         {: RESULT = new stmt(7, id);  :}
//         | ID:i L_PARAN args:a R_PARAN SEMI 
//         {: RESULT = new stmt(8, id, a);  :}
//         | RETURN SEMI
//         {: RESULT = new stmt(9);  :}
//         | RETURN expr:e SEMI
//         {: RESULT = new stmt(10, e);  :}
//         | name:n INCREMENT SEMI
//         {: RESULT = new stmt(11, n);  :}
//         | name:n DECREMENT SEMI
//         {: RESULT = new stmt(12, n);  :}
//         | L_BRACE fielddecls:f stmts:s R_BRACE Optionalsemi
//         {: RESULT = new stmt(13,f, s);  :}
//         ;

// ifEnd ::= ELSE stmt:s 
//         {: RESULT = new ifEnd(s);  :}
//         | /* the empty production */
//         ;

name ::= ID:id 
        {: RESULT = new Name(id);  :}
        ;

// name ::= ID:i 
//         {: RESULT = new name(i);  :}
//         | ID:i L_BRACKET expr:e R_BRACKET
//         {: RESULT = new name(i, e);  :}
//         ;

// args ::= expr:e COMMA args:a 
//      {: RESULT = new args(e, a);  :}
//      | expr:e 
//      {: RESULT = new args(e);  :}
//      ;

// readlist ::= name:n COMMA readlist:r 
//          {: RESULT = new readlist(n, r);  :}
//          | name:n 
//          {: RESULT = new readlist(n);  :}
//          ;


// printlist ::= expr:e COMMA printlist:p 
//           {: RESULT = new printlist(e, p);  :}
//           | expr: e
//           {: RESULT = new printlist(e);  :}
//           ;

printlist ::= expr: e 
          {: RESULT = new Printlist(e);  :}
          ;


// printlinelist ::= printlist:p 
//               {: RESULT = new printlinelist(p);  :}
//               | /* the empty production */
//               ;



expr ::= name:n 
        {: RESULT = new Expr(n);  :}
        | ID:id L_PARAN R_PARAN 
        {: RESULT = new Expr(id, null);  :}
        | ID:id L_PARAN args:a R_PARAN 
        {: RESULT = new Expr(id, a);  :}
        | INTLIT:il 
        {: RESULT = new Expr(Integer.parseInt(il));  :}
        | CHARLIT:cl 
        {: RESULT = new expr(cl, "char");  :}
        | STRLIT:sl 
        {: RESULT = new expr(sl, "str");  :}
        | FLOATLIT:fl 
        {: RESULT = new expr(Float.parseFloat(fl));  :}
        | TRUE
        {: RESULT = new expr(true);  :}
        | FALSE
        {: RESULT = new expr(false);  :}
        | L_PARAN expr:e R_PARAN 
        {: RESULT = new expr(e, "PARA");  :}
        | NEGATION expr:e 
        {: RESULT = new expr(e, "~");  :}
        | PREFIXMINUS expr:e 
        {: RESULT = new expr(e, "-");  :}
        | PREFIXPLUS expr:e
        {: RESULT = new expr(e, "+");  :}
        | L_PARAN type:t R_PARAN expr:e 
        {: RESULT = new expr(t, e);  :}
        | expr:e1 binaryOp:bo expr:e2
        {: RESULT = new expr(e1, e2, bo);  :}
        | L_PARAN expr:e1 TERNARY expr:e2 COLON expr:e3 R_PARAN 
        {: RESULT = new expr(e1, e2, e3);  :}
        ;


// binaryOp ::= TIMES
//         {: RESULT = new binaryOp("*");  :}
//         | DIVIDE 
//         {: RESULT = new binaryOp("/");  :}
//         | PLUS 
//         {: RESULT = new binaryOp("+");  :}
//         | MINUS 
//         {: RESULT = new binaryOp("-");  :}
//         | LT 
//         {: RESULT = new binaryOp("<");  :}
//         | GT 
//         {: RESULT = new binaryOp(">");  :}
//         | LTE
//         {: RESULT = new binaryOp("<=");  :}
//         | GTE
//         {: RESULT = new binaryOp(">=");  :}
//         | EQ 
//         {: RESULT = new binaryOp("==");  :}
//         | NOT_EQ 
//         {: RESULT = new binaryOp("<>");  :}
//         | OR
//         {: RESULT = new binaryOp("||");  :}
//         | AND
//         {: RESULT = new binaryOp("&&");  :}

